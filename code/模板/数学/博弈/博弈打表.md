# 博弈打表
## 有趣的打表
### 1xN格子，两个人轮流放S/O，形成SOS win
```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef pair<int,int> P;
#define int long long
int a[2000];
int has(int n)
{
    int sum=0;
    for(int i=1;i<=n;i++)sum=sum*3+a[i];
    return sum;
}
int check(int n)
{
    for(int i=3;i<=n;i++){
        if(a[i]==1&&a[i-1]==2&&a[i-2]==1)return 1;
    }
    return 0;
}
void show(int n)
{
    for(int i=1;i<=n;i++)cout<<a[i]<<" ";
    puts("");
}
int dfs(int cnt,int n)
{
    int ha=has(n);
    int &res=mp[ha];
    if(res)return res;//已经求出来过
    if(check(n))return res=-1;//P
    if(cnt==n)return res=-10;//D
    int flag=0;
    for(int i=1;i<=n;i++){
        if(a[i])continue;//1S 2O
        for(int j=1;j<=2;j++){
            a[i]=j;
            int t=dfs(cnt+1,n);
            a[i]=0;
            if(t==-1)return res=1;
            if(t==-10)flag=1;
        }
    }
    return res=flag?-10:-1;
}
void solve()
{
	for(int i=1;i<=30;i++){
        mp.clear();
        memset(a,0,sizeof(a));
        int t=dfs(0,i);//从0开始到n
        printf("%lld:%lld\t",i,t);
    }
}
signed main()
{
	int __=1;
	//cin >> __;
	while (__--)
		solve();
}
```

## 威佐夫博弈
有两堆石子，个数为 `(a[k],b[k])`；A，B轮流取石子，规定要么只取一堆的任意多个，
```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef pair<int,int> P;
#define int long long
int pn[1003][1003];
int dfs(int x,int y)
{
    int &res=pn[x][y];
    if(res!=-1)return res;
    if(x==y)return res=1;
    int mi=min(x,y);
    for(int i=1;i<=mi;i++){
        int t=dfs(x-i,y-i);
        if(t==0)return res=1;
    }
    for(int i=1;i<=x;i++){
        int t=dfs(x-i,y);
        if(t==0)return res=1;
    }
    for(int i=1;i<=y;i++){
        int t=dfs(x,y-i);
        if(t==0)return res=1;
    }
    return res=0;
}
void solve()
{
	memset(pn,-1,sizeof(pn));
    pn[0][0]=0;
    dfs(23,23);
    for(int i=0;i<=25;i++){
        for(int j=0;j<=25;j++){
            dfs(i,j);
            cout<<pn[i][j]<<" ";
        }
        puts("");
    }
}
signed main()
{
	int __=1;
	//cin >> __;
	while (__--)
		solve();
}
```
## Nim游戏+拆成两堆
即多了一个SG(x+y)的过程
```c++
#include <bits/stdc++.h>
#define maxn 105
using namespace std;
int vis[maxn];
int sg[maxn];
void init(){//SG函数打表
    for(int i=0;i<100;i++){//枚举100个状态
        memset(vis,0,sizeof(vis));
        for(int j=1;j<=i;j++){
            vis[sg[i-j]]=true;
        }
        for(int j=1;j<i;j++){//枚举分成两块的状态
            vis[sg[j]^sg[i-j]]=true;
        }
        for(int j=0;;j++){
            if(!vis[j]){
                sg[i]=j;
                break;
            }
        }
    }
    for(int i=0;i<100;i++){
        cout<<i<<" "<<sg[i]<<endl;
    }
}
int SG(int n){
    if(n%4==1||n%4==2) return n;
    else if(n%4==3) return n+1;
    else return n-1;
}
int main()
{
    //init();
    int t;
    scanf("%d",&t);
    while(t--){
        int n;
        scanf("%d",&n);
        int res=0;
        for(int i=0;i<n;i++){
            int num;
            scanf("%d",&num);
            res^=SG(num);
        }
        if(res) puts("Alice");
        else puts("Bob");
    }
    return 0;
}
```